Working of Pass-1:
Step-1: START 200 (here no symbol or literal is found so both table would be empty)
Step-2: MOVER R1, =’3′ 200 ( =’3′ is a literal so literal table is made)
Step-3: MOVEM R1, X 201 X is a symbol referred prior to its declaration so it is stored in symbol table with blank address field.
Step-4: L1 MOVER R2, =’2′ 202 L1 is a label and =’2′ is a literal so store them in respective tables
Step-5: LTORG 203 Assign address to first literal specified by LC value, i.e., 203
Step-6: X DS 1 204 It is a data declaration statement i.e X is assigned data space of 1. But X is a symbol which was referred earlier in step 3 and defined in step 6.This condition is called Forward Reference Problem where variable is referred prior to its declaration and can be solved by back-patching. So now assembler will assign X the address specified by LC value of current step.
Step-7: END 205 Program finishes execution and remaining literal will get address specified by LC value of END instruction. Here is the complete symbol and literal table made by pass 1 of assembler.
Now tables generated by pass 1 along with their LC value will go to pass-2 of assembler for further processing of pseudo-opcodes and machine op-codes.

Working of Pass-2:
Pass-2 of assembler generates machine code by converting symbolic machine-opcodes into their respective bit configuration(machine understandable form). It stores all machine-opcodes in MOT table (op-code table) with symbolic code, their length and their bit configuration. It will also process pseudo-ops and will store them in POT table(pseudo-op table).

Various Data bases required by pass-2:

1. MOT table(machine opcode table)
2. POT table(pseudo opcode table)
3. Base table(storing value of base register)
4. LC ( location counter)

output ->
farhan@pop-os:~/Documents/workspace/CodingPractice/spcc/pass$ python3 pass*
Enter the no of instruction lines : 3
Enter instruction line 1 : MOV R
Enter instruction line 2 : ADD R
Enter instruction line 3 : DCR R
Symbol Table  :  


 Symbol           Value(Address)

 Pass-1 machine code output without reference of the symbolic address : 

Relative Address        Instruction         OpCode
0                                 MOV R               1 
1                                 ADD R               8 
2                                 DCR R               16 

 Pass-2 output: Machine code output 
 
Relative Address        Instruction         OpCode
0                                 MOV R               1 
1                                 ADD R               8 
2                                 DCR R               16 